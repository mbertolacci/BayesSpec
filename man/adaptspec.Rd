% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/adaptspec.R
\name{adaptspec}
\alias{adaptspec}
\title{Adaptive Spectral Estimation for Non-stationary Time Series}
\usage{
adaptspec(
  # Sampler
  n_loop,
  n_warm_up,
  # Data
  data,
  detrend = TRUE,
  # Model
  n_segments_min = 1,
  n_segments_max = 10,
  t_min = time_step * floor(40 / time_step),
  sigma_squared_alpha = 100,
  tau_prior_a = -1,
  tau_prior_b = 0,
  tau_upper_limit = 10000,
  n_bases = 7,
  time_step = 1,
  # Sampler control
  prob_mm1 = 0.8,
  var_inflate = 1,
  burn_in_var_inflate = var_inflate,
  start = list(
    n_segments = NULL,
    cut_points = NULL,
    beta = NULL,
    tau_squared = NULL,
    x_missing = NULL
  ),
  thin = list(
    n_segments = 1,
    beta = 1,
    tau_squared = 1,
    cut_points = 1,
    log_posterior = 1,
    x_missing = 1
  ),
  show_progress = FALSE,
  # Extra
  run_diagnostics = TRUE
)
}
\arguments{
\item{n_loop}{Number of MCMC iterations to perform}

\item{n_warm_up}{Number of warm-up iterations to discard, so that the
number of samples returned is n_loop - n_warm_up}

\item{data}{Numeric vector or matrix of data. If a matrix, the model assumes
it has multiple independent observations of the same random process, one per
column.}

\item{detrend}{Whether to remove a mean and linear trend from the time-series
prior to fitting. If \code{data} is a matrix, this will be done independently for
each column.}

\item{n_segments_min}{Minimum number of segments}

\item{n_segments_max}{Maximum number of segments}

\item{t_min}{Minimum number of observations per segment}

\item{sigma_squared_alpha}{Prior variance of smoothing spline intercept}

\item{tau_prior_a}{Shape of truncated inverse gamma prior for smoothing
spline smoothing parameter}

\item{tau_prior_b}{Scale of truncated inverse gamma prior for smoothing
spline smoothing parameter}

\item{tau_upper_limit}{Upper truncation point for inverse gamma prior for
smoothing spline smoothing parameter}

\item{n_bases}{Number of spline basis vectors to use for log spectrum}

\item{time_step}{Restricts cut points to times divisible by this number}

\item{prob_mm1}{Tuning parameter for MCMC scheme determining the proposal
for moving cutpoint}

\item{var_inflate}{Factor by which to inflate the adaptive proposal
covariance for the smoothing spline parameters}

\item{burn_in_var_inflate}{As with var_inflate, but applies only during
the warm up phase}

\item{start}{Starting values for MCMC chain. Initialised randomly if blank.
Can be provided an adaptspecfit object in order to continue a previous chain.}

\item{thin}{A list specifying how to thin each output of the MCMC sampler.
A value of 1 indicates no thinning, 2 keeps every second sample, and so on.}

\item{show_progress}{Whether to show a progress indicator during MCMC.}

\item{run_diagnostics}{Whether to run diagnostics afterwards to determine
whether the chain has reached convergence.}
}
\value{
An object of class \code{adaptspecfit}. The MCMC samples are available
under the following list entries, each of which are of class
\code{\link[coda]{mcmc}} or \code{\link[acoda]{mcmca}}:
\itemize{
  \item \code{n_segments}: Integer vector with samples of number of segments.
  \item \code{cut_points}: Integer matrix with samples of each cut point, with
  segment 1 cut point in column 1, and so on. Cells to the right of the
  number of segments in that iteration are set to the length of the time
  series.
  \item \code{tau_squared}: Numeric matrix with samples of smoothing spline
  smoothing parameters. Layout is as for `cut_points`.
  \item \code{beta}: Three dimensional array with samples of smoothing spline
  parameters for each segment.
  \item \code{x_missing}: List of numeric matrices, where each matrix holds the
  samples of missing values for each column in `data`
  \item \code{log_posterior}: Numeric vector of unnormalised values of the log
  posterior in each iteration.
}
}
\description{
This function implements a methodology for analyzing possibly non-stationary
time series by adaptively dividing the time series into an unknown but finite
number of segments and estimating the corresponding local spectra by
smoothing splines.
}
\examples{
# Running adaptspec with the simulated_piecewise data.
data(simulated_piecewise)
model1 <- adaptspec(
  5000,
  1000,
  simulated_piecewise
)
summary(model1)
}
\seealso{
\code{\link{segment_log_spectra_mean}} for methods calculating
estimates of the spectral densities modelled. \code{\link{adaptspecfit}} for
useful methods applying to objects returned by this function.
}
