% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/adaptspec.R
\name{adaptspec}
\alias{adaptspec}
\alias{adaptspec_model}
\alias{adaptspec_sample}
\title{AdaptSPEC: Adaptive Spectral Estimation for Non-stationary Time Series}
\usage{
adaptspec(
  # Sampler
  n_loop,
  n_warm_up,
  # Data
  data,
  detrend = FALSE,
  # Model
  n_segments_min = 1,
  n_segments_max = 10,
  t_min = time_step * floor(40 / time_step),
  sigma_squared_alpha = 100,
  tau_prior_a = -1,
  tau_prior_b = 0,
  tau_upper_limit = 10000,
  n_bases = 7,
  time_step = 1,
  frequency_transform = c('identity', 'cbrt'),
  segment_means = FALSE,
  mu_lower = -1000,
  mu_upper = 1000,
  # Sampler control
  tuning = adaptspec_tuning(),
  # Starting values
  start = list(
    n_segments = NULL,
    cut_points = NULL,
    beta = NULL,
    tau_squared = NULL,
    x_missing = NULL
  ),
  thin = list(
    n_segments = 1,
    beta = 1,
    tau_squared = 1,
    cut_points = 1,
    mu = 1,
    log_posterior = 1,
    x_missing = 1
  ),
  show_progress = FALSE,
  debug = FALSE,
  # Extra
  run_diagnostics = TRUE
)

adaptspec_model(
  n_segments_min = 1,
  n_segments_max = 10,
  t_min = time_step * floor(40/time_step),
  sigma_squared_alpha = 100,
  tau_prior_a = -1,
  tau_prior_b = 0,
  tau_upper_limit = 10000,
  n_bases = 7,
  time_step = 1,
  frequency_transform = c("identity", "cbrt"),
  segment_means = FALSE,
  mu_lower = -1000,
  mu_upper = 1000
)

adaptspec_sample(
  model,
  n_loop,
  n_warm_up,
  data,
  detrend = TRUE,
  tuning = adaptspec_tuning(),
  start = list(
    n_segments = NULL,
    cut_points = NULL,
    beta = NULL,
    tau_squared = NULL,
    x_missing = NULL
  ),
  thin = list(
    n_segments = 1,
    beta = 1,
    tau_squared = 1,
    cut_points = 1,
    mu = 1,
    log_posterior = 1,
    x_missing = 1
  ),
  show_progress = FALSE,
  debug = FALSE,
  run_diagnostics = TRUE
)
}
\arguments{
\item{n_loop}{Number of MCMC iterations to perform}

\item{n_warm_up}{Number of warm-up iterations to discard, so that the
number of samples returned is n_loop - n_warm_up}

\item{data}{Numeric vector or matrix of data. If a matrix, the model assumes
it has multiple independent observations of the same random process, one per
column.}

\item{detrend}{Whether to remove a mean and linear trend from the time-series
prior to fitting. If \code{data} is a matrix, this will be done independently
for each column.}

\item{n_segments_min}{Minimum number of segments}

\item{n_segments_max}{Maximum number of segments}

\item{t_min}{Minimum number of observations per segment}

\item{sigma_squared_alpha}{Prior variance of smoothing spline intercept}

\item{tau_prior_a}{Shape of truncated inverse gamma prior for smoothing
spline smoothing parameter}

\item{tau_prior_b}{Scale of truncated inverse gamma prior for smoothing
spline smoothing parameter}

\item{tau_upper_limit}{Upper truncation point for inverse gamma prior for
smoothing spline smoothing parameter}

\item{n_bases}{Number of spline basis vectors to use for log spectrum}

\item{time_step}{Restricts cut points to times divisible by this number}

\item{frequency_transform}{How to transform frequencies prior to fitting
smoothing spline. Defaults to no transformation.}

\item{segment_means}{Whether to assume the mean is zero in each segment
(FALSE, the default), or estimate segment means}

\item{mu_lower}{Lower bound of uniform for segment means}

\item{mu_upper}{Upper bound of uniform for segment means}

\item{tuning}{Tuning parameters for the MCMC scheme, created through the
\code{\link{adaptspec_tuning}} function.}

\item{start}{Starting values for MCMC chain. Initialised randomly if blank.
Can be provided an adaptspecfit object in order to continue a previous chain.}

\item{thin}{A list specifying how to thin each output of the MCMC sampler.
A value of 1 indicates no thinning, 2 keeps every second sample, and so on.}

\item{show_progress}{Whether to show a progress indicator during MCMC.}

\item{debug}{If enabled, the sampler will output debug information on each
iteration}

\item{run_diagnostics}{Whether to run diagnostics afterwards to help
determine whether the chain has reached convergence.}

\item{model}{An object created with \code{adaptspec_model}}
}
\value{
An object of class \code{adaptspecfit}. The MCMC samples are
available under the following list entries, each of which are of class
\code{\link[coda]{mcmc}} or \code{\link[acoda]{mcmca}}:
\itemize{
  \item \code{n_segments}: Integer vector with samples of number of segments.
  \item \code{cut_points}: Integer matrix with samples of each cut point,
  with segment 1 cut point in column 1, and so on. Cells to the right of the
  number of segments in that iteration are set to the length of the time
  series.
  \item \code{mu}: Numeric matrix with samples of segment means. Layout is
  as for `cut_points`.
  \item \code{tau_squared}: Numeric matrix with samples of smoothing spline
  smoothing parameters. Layout is as for `cut_points`.
  \item \code{beta}: Three dimensional array with samples of smoothing spline
  parameters for each segment.
  \item \code{x_missing}: List of numeric matrices, where each matrix holds
  the samples of missing values for each column in `data`
  \item \code{log_posterior}: Numeric vector of unnormalised values of the
  log posterior in each iteration.
}
}
\description{
This function implements a methodology for analyzing possibly non-stationary
time series by adaptively dividing the time series into an unknown but finite
number of segments and estimating the corresponding local spectra by
smoothing splines.
}
\section{Functions}{
\itemize{
\item \code{adaptspec_model}: Constructs an object representing an AdaptSPEC model

\item \code{adaptspec_sample}: Uses MCMC to sample from the posterior of an AdaptSPEC
model given data
}}

\examples{
# Running adaptspec with the simulated_piecewise data.
data(simulated_piecewise)
model1 <- adaptspec(
  5000,
  1000,
  simulated_piecewise
)
summary(model1)
}
\seealso{
\code{\link{time_varying_mean_mean.adaptspecfit}} for estimates of the
time-varying mean.
\code{\link{time_varying_spectra_mean.adaptspecfit}} for estimates of the
time-varying spectral density.
\code{\link{adaptspecfit}} for other useful methods applying to objects
returned by this function.
\code{\link{segment_log_spectra_mean}} for methods calculating estimates of
the spectral densities in each segments.
\code{\link{cut_point_pmf}} to return the estimated probability mass function
of the cutpoints.
\code{\link{merge_samples}} to merge samples from independent runs of this
function.
}
